% https://www.overleaf.com/learn

\documentclass{article}
\usepackage{layout}
\usepackage[T1]{fontenc} 
\usepackage[italian]{babel}
\usepackage{hyphenat}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{geometry}
\setlength{\textheight}{640pt}
\geometry{
  a4paper,
  % total={170mm,257mm},
  % left=20mm,
  top=30mm,
  bottom=30mm,
}
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\title{Progetto Esame Algorithmic Game Theory}
\author{Paola Guarasci --- mat 231847}
\date{\today}

% Nel senso, puoi impostare tutto in modo molto discorsivo
% Nessuno ti obbliga ad usare il matematichese
% Quello che devi scrivere è un algoritmo
% Prima definisci input e output
% E dopo inizi a dire che il tuo algoritmo procede così:
% 1 - .... 2- ..... 3-.....
% E poi ci attacchi pseudocodice o codice relativo e alla fine puoi fare un esempio

\lstset{style=mystyle}

% \hyphenation{mate-mati-ca recu-perare}

\begin{document}
\maketitle

% \pagebreak
\section*{Descrizione}
\paragraph*{Problema iniziale}
DESCRIZIONE DEL PROBLEMA INIZIALE 
% \paragraph*{}
% \begin{itemize}
%   \item Si tratta di un gioco baesiano (informazioni private dei giocatori)
%   \item Si tratta di un meccanismo diretto perche' le possibili azioni di ogni agente sono effettivamente le preferenze di ogni agente
%   \item Devo implementare un meccanismo in cui la strategia dominante e' dire la verita', serve una scf che sia non manibolabile e a prova di strategia.
%   \item Il fatto che si prende in considerazione il prezzo rende il meccanismo a prova di menzogna perche' e' affidabile. 
% \end{itemize}
\paragraph*{Input}
L'algoritmo in input si aspetta una lista di tipi, uno per ogni utente. Il tipo rappresenta la localita' preferita di ogni agente. E' stata introdotta una semplificazione riguardo al problema posto originariamente: gli agenti non forniscono una lista di preferenze bensi' una sola preferenza di cui ci si puo' fidare poiche' e' stato adottato un meccanismo di scelta basato sul mento massimo che ogni agente e' disposto ad effettuare. Quindi, poiche' dell'affermazione sul pagamento ci si puo' fidare, allora si e' deciso di usare questo criterio come distriminante per quanto riguarda l'inserimento del singolo agente nel sottoinsieme travellers, cioe' l'insieme dei viaggiatori. 
\paragraph*{Grafo}
Le localita' sono rappresentate da un grafo pesato non orientato. Ogni localita', ovvero ogni nodo, e' connessa con tutte le altre localita'. I pesi sugli archi indicano la distanza in chilometri tra i due nodi alle estremita' di ogni arco. 
Il calcolo del percorso ottimale e del suo costo e' stato modellato usando l'algoritmo di Dijkstra e risolvendo il problema del Commesso Viaggiatore. Per far cio' ci siamo avvalsi di una ottima libreria in Python per la manipolazione di grafi, la libreria NetworkX\footnote{La libreria ha licenza BSD (Open Source) ed e' scaricabile qui https://networkx.org/}. La funzione di libreria \verb|approx.greedy_tsp(graph)| prende in input un grafo (o porzione di esso) e ne calcola il cammino hemiltoniano.
Per avere il costo del cammino la formula usata e' la seguente:
\begin{lstlisting}[language=Python]
cost = sum(graph[n][nbr]["weight"] for n, nbr in nx.utils.pairwise(cycle))
\end{lstlisting}
Il grafo e' modellato come una lista di tuple di archi con tre valori: nodo di partenza, nodo di arrivo, peso. 
I nodi sono inferiti dalla lista di archi. 

\paragraph*{Output}
In output ho una serie di 
\paragraph*{Meccanismo}
Il core del progetto e' l'algoritmo di selezione degli agenti. Per ogni agente si valuta la possibilita' di inclusione nel gruppo di viaggiatori, i \verb|travellers|, usando la seguente strategia di selezione:
 \begin{itemize}
   \item Si tratta di un gioco baesiano (informazioni private dei giocatori)
   \item Si tratta di un meccanismo diretto perche' le possibili azioni di ogni agente sono effettivamente le preferenze di ogni agente
   \item Devo implementare un meccanismo in cui la strategia dominante e' dire la verita', serve una scf che sia non manibolabile e a prova di strategia.
   \item Il fatto che si prende in considerazione il prezzo rende il meccanismo a prova di menzogna perche' e' affidabile. 
 \end{itemize}


\paragraph*{}

\paragraph*{}
\clearpage
\pagebreak
\section*{Implementazione}
\lstinputlisting[language=Python]{../src/path.py}
\end{document}